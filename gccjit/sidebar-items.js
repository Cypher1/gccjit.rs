initSidebarItems({"enum":[["BinaryOp","BinaryOp is a enum representing the various binary operations that gccjit knows how to codegen."],["FunctionType","FunctionType informs gccjit what sort of function a new function will be. An exported function is a function that will be exported using the CompileResult interface, able to be called outside of the jit. An internal function is a function that cannot be called outside of jitted code. An extern function is a function with external linkage, and always inline is a function that is always inlined wherever it is called and cannot be accessed outside of the jit."],["OptimizationLevel","Represents an optimization level that the JIT compiler will use when compiling your code."],["UnaryOp","UnaryOp is an enum representing the various unary operations that gccjit knows how to codegen."]],"struct":[["Block","Block represents a basic block in gccjit. Blocks are created by functions. A basic block consists of a series of instructions terminated by a terminator instruction, which can be either a jump to one block, a conditional branch to two blocks (true/false branches), a return, or a void return."],["CompileResult","Represents a successful compilation of a context. This type provides the means to access compiled functions and globals. JIT compiled functions are exposted to Rust as an extern \"C\" function pointer."],["Context","Wrapper around a GCC JIT context object that keeps the state of the JIT compiler. In GCCJIT, this object is responsible for all memory management of JIT data structures, and as such anything made from this context must have a lifetime strictly less than this object."],["Field","Field represents a field that composes structs or unions. A number of fields can be combined to create either a struct or a union."],["Function","Function is gccjit's representation of a function. Functions are constructed by constructing basic blocks and connecting them together. Locals are declared at the function level."],["LValue","An LValue in gccjit represents a value that has a concrete location in memory. A LValue can be converted into an RValue through the ToRValue trait. It is also possible to get the address of an LValue."],["Location","A Location represents a location used when debugging jitted code."],["Object","Object represents the root of all objects in gccjit. It is not useful in and of itself, but it provides the implementation for Debug used by most objects in this library."],["Parameter","Parameter represents a parameter to a function. A series of parameteres can be combined to form a function signature."],["RValue","An RValue is a value that may or may not have a storage address in gccjit. RValues can be dereferenced, used for field accesses, and are the parameters given to a majority of the gccjit API calls."],["Struct","A Struct is gccjit's representation of a composite type. Despite the name, Struct can represent either a struct, an union, or an opaque named type."],["Type","A representation of a type, as it is known to the JIT compiler. Types can be created through the Typeable trait or they can be created dynamically by composing Field types."]],"trait":[["ToLValue","ToLValue is a trait implemented by types that can be converted (or treated as) LValues."],["ToObject","ToObject is a trait implemented by types that can be upcast to Object."],["ToRValue","ToRValue is a trait implemented by types that can be converted to, or treated as, an RValue."],["Typeable","Typeable is a trait for types that have a corresponding type within gccjit. This library implements this type for a variety of primitive types, but it's also possible to implement this trait for more complex types that will use the API on Context to construct analagous struct/union types."]]});